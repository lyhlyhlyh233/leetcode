1, 回溯算法
    回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。
    但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

    思路：
    ①写一个用来递归、回溯的方法,②用一个数组来存放已经访问与否，还有偏移数组的使用
    不要关注位置坐标，不重要。不用特殊关注第一个点。
    递归:下一个判断逻辑留给下一个递归.递归终点要选择好。
    经典问题：n皇后，尚未完成。

2,  两数之和
    暴力求解
    或者用hashmap来保存数据的值与位置。然后通过寻找每个数是否存在对应的补数即可。

3,  删除链表中的一个节点
    只给要删的节点信息。可以通过后面节点值的前移来解决。

4,  二叉树的深度，
    方法1：递归。深度优先搜索。
    方法2：迭代。广度优先搜索。 尚未完成。

5,  有序数组转换为高度平衡的二叉搜索树
    二叉搜索树：符合二叉树且节点n左子树所有节点的值都分别小于n,右子树的值都大于n。
    高度平衡：每个节点的左右两个字数高度相差不超过1。
    本题存在多解。
    前序遍历：中 - 左 - 右
    中序遍历：左 - 中 - 右
    后序遍历：左 - 右 - 中  记忆要诀  先记后序遍历，前序遍历相反从顶部到底部。
    此题无需判断左右子树高度，通过每次都选择中间节点来解决即可。
    数组截取：传递开始结束下标给下一个方法即可。
    递归：子节点返回自己的根。
    取中点 ： (x+y)/2 与 x+(y-x)/2的结果不一致

6, 反转数组：前后互相交换。
   反转链表：遍历第一遍的时候复制出一个链表出来。

7,异或要点：a^0 = a,    a^a=0。满足交换律。
8,位操作的小技巧：n&(n-1)   总能把n的最后一位变成0
9,众数
    ①先排序，中位数即是众数
          快排。
    ②投票算法  ： 当计数为0时重新选择候选数，当遇到候选数是+1，否则-1

10,合并链表：递归。
      合并数组：双指针，（在函数内对变量直接赋值，在函数外不可见：堆与栈，引用与对象）；
 11 移动0：快慢指针

 12 股票买卖  ： 暴力搜索 动态规划 贪心算法
       暴力搜索 ：将买和卖的动作转化为每天持有不持有的状态。将买和卖的差价转化为自己手里的前还剩多少。
       贪心算法 ：
       动态规划：可以用贪心算法解决的问题，一般情况下都可以用动态规划
       dp[i][j]   三个意义。 dp  i  j

 13 通过与运算和异或来求和
 14 链表相交：
15  最大子序列和   动态规划。dp[i] = Math.max(dp[i-1],0)+nums[i];
16 链表中 ：快慢指针可以用来找中点,
                      翻转链表  pre cur  反转数组
 17  找indexof  可以用滑动窗口
           kmp算法：字符串匹配
  18 二分法： while(left<=right){
                         mid = left+(right-left)/2;
                           if(temp<x){
                                             left = mid+1;
                            }
                            if(temp>x){
                                             right = mid-1;
                              }

                             long temp = (long)mid*mid;   转换
 19 数字处理  Math.abs  对于等于整数边界范围的，不进行处理



